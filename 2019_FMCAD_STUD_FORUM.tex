% Oliver Kullmann, 18.5.2019 (Swansea)
% Bibtex entry \cite{KullmannShukla2019DQCNF}.
% Underlying report: 2018_DQBF.tex \cite{KullmannShukla2018DQBF}.
% Submitted to FMCAD 2019 https://fmcad.forsyte.at/FMCAD19/ :
% ID 79d524970076dd8509ffbd92da4922bba7682e3b.

\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts


\input Latex_macros/Definitionen.tex

\usepackage{enumerate}
\usepackage[all]{xy}
\usepackage[active]{srcltx}

\interdisplaylinepenalty=2500

\DeclareMathOperator{\varess}{\var_{es}} % essential variables

\DeclareMathOperator{\Aaut}{A}
\DeclareMathOperator{\Eaut}{E}


\begin{document}

\title{Improving Reasoning on DQBF}


\author{
\IEEEauthorblockN{Ankit Shukla}
\IEEEauthorblockA{
Johannes Kepler University, Austria\\
Email: ankit.shukla@jku.at}
}

\maketitle

\begin{abstract}
In this paper we investigate two techniques, autarkies and symmetry to improve the reasoning with the Dependency Quantified Boolean Formulas (DQBF).
%
DQBF extend QBF with non-linear dependencies between the quantified variables.
%
Motivated by the models for generating random QBF instances, we give an overview of a general model for generating random DQBF instances.	
%
The tool is under development. 
%We are developing tools for improving correctness of tools like fuzzer (what is the random generator) and delta-debugger.
%    
\end{abstract}



\section{Introduction}
\label{sec:Intro}
Dependency Quantified Boolean Formulas (DQBF) are an extension of QBF
which allows the specification of non-linear dependencies between quantified variables. 
%
%In the case of QBF the variable dependencies always follow a
%linear order (each existential variable depends on all universal variables left of its position in the quantifier prefix).
%
%The DQBF problem permits the modeling of problems known to be NEXPTIME-complete, e.g. partial information non-cooperative games or probabilistic planning of finite length, or certain bit-vector logics making DQBF an idea formalism to express them.
For example \par\noindent
%\begin{align}
%\nonumber\\
% \nonumber
%	%
%\end{align}
%
\begin{equation}
\begin{split}
&F := \fa x_1,x_2,x_3 \ex y_1(x_1,x_2) \ex y_2(x_2,x_3) \ex y_3(x_1): F_0 \\
&F_0 := (y_1 \vee x_1) \wedge (\overline{y_1} \vee x_2) \wedge (\overline{y_2} \vee \overline{x_2} \vee x_3) \\
&\hspace{2.3cm}\wedge (y_3 \vee \overline{x_1} \vee x_2) \wedge (\overline{y_3} \vee x_1)
\end{split}
\label{eqn:ex}
\end{equation}

is a DQBF formula where explicit dependencies ($(x_1,x_2), (x_2,x_3), (x_1)$) of quantified existential variables ($y_1, y_2, y_3$ respectively) are specified. We call the explicit dependencies the \textit{dependency set} of the corresponding variables. 
%
%
DQBF can offers more succinct descriptions than
QBF, provided that the two classes do not collapse.
%
Deciding DQBF is NEXPTIME-complete, compared to the PSPACE completeness of QBF.
%
Making it suitable to model problems known to be NEXPTIME-complete, e.g. partial information non-cooperative games, probabilistic planning of finite length, and certain bit-vector logics.
%The DQBF problem permits the modeling of problems like partial information non-cooperative games, probabilistic planning of finite length, and certain bit-vector logics etc.
%For example, the dependency set of the existential variable $y_1$ is  $\{x_1,x_2\}$. 
%$\{x_2,x_3\}, \{x_1\}$

\section{preprocessing}
\label{sec:pre}

We present two techniques autarkies and symmetry that can be basis for pre-processing and in-processing of DQBF solving process. 
%
We have recently proposed the autarky theory with simple autarky systems (namely $A_0$, $A_1$ and $E_1$) for DQBF. 
%
Here we give an overview of the autarky theory and outline the more stronger autarky systems $A_2$, $E_2$ and $E_2 + A_2$. 
%

Symmetries are well understood and successfully exploited in the case of SAT. 
%
Recently general framework of symmetry for QBF was proposed \cite{kauers2018symmetries}.
%
Here, we present an overview of our current work of extending the symmetries from QBF to DQBF.   

\subsection{Autarkies}
\label{sec:aut}
An autarky for a CNF $F$ is a partial assignment (mapping variables of the formula to 0 or 1) which satisfies every clause of $F$ containing an assigned variable. 
%
Clauses satisfied by some autarky can be removed satisfiability-equivalently. 
%
We generalize the concept for DQBF by considering partial assignments to existential variables and allowing boolean functions of universal variables as values (fulfilling the dependencies) substituted for them.
%
Now the clauses with assigned variables need to become tautologies.
%
Note that an empty partial assignment is an autarky for every $F$ i.e. never touching any clause (\textit{trivial autarky}) and a satisfying assignment for $F$ is also an autarky for $F$, touching every clause and satisfying it.

A DQBF is called \textbf{lean} if it has no non-trivial autarkies.
The union of two lean DQCNF with compatible variables and dependencies is again lean, and thus every DQBF has a largest lean sub-DQBF, the \textbf{lean kernel}.
%We denote the lean kernel by $\bm{\na(F)}$ (``N'' like ``normal form'').
Alternatively one can arrive at the lean kernel via \textbf{autarky reduction}.
For an autarky $\vp$ of a DQBF we denote by $\vp * F$ the DQBF with the clauses removed which are satisfied by $\vp$.
\begin{lem}\label{lem:autsateq}
	$\vp * F$ is satisfiability-equivalent to $F$ for an autarky $\vp$ of $F$.
\end{lem}
For two autarkies $\vp, \psi$ of $F$ one can consider the composition $\vp \circ \psi$, which on the variables of $\psi$ acts like $\psi$, and otherwise like $\vp$:
\begin{lem}\label{lem:compaut}
	The composition of two autarkies is again an autarky.
\end{lem}
Now the lean kernel is obtained by repeatedly applying autarky-reduction on $F$ as long as possible:
\begin{lem}\label{lem:decomp}
	Consider a DQBF $F$. The largest lean sub-DQBF is also obtained by applying autarky-reduction to $F$ as long as possible (in any order).
\end{lem}

We present two types of autarky systems for DQBF, namely, $A$ and $E$ (using ``A" to denote universal variables, and ``E" for existential variables).
%
Consider a DQCNF $F$ and $k \ge 0$:
\begin{itemize}
	\item An \textbf{$\Aaut_k$-autarky} for $F$ is an autarky such that all boolean functions assigned depend essentially on at most $k$ variables.
	\item An \textbf{$\Eaut_k$-autarky} is an autarky assigns at most $k$ (existential) variables.
\end{itemize}

%\subsubsection{A}
$A_0, A_1$ allow the boolean functions to essentially depend on 0 resp. 1 universal variable, while $E_1$ only uses one existential variable (for a single autarky).
%$A_0, A_1, A_2$ restrict the structure of the boolean function, by forcing the existential variable to depend on at most 0, 1, 2 universal variable.
%\subsubsection{E}
%$E_1, E_2$ only uses one and two existential variable.
%

Consider the Example~\ref{eqn:ex}
Since $\overline{y_2}$ is pure, we have the $\Aaut_0$-autarky $y_2 \rightarrow 0$ (removing the third clause).
Furthermore we have the $\Aaut_1$-autarky $y_3 \rightarrow x_1$, removing the fourth and fifth clauses.
Both these autarkies are also $\Eaut_1$-autarkies.
We obtain the reduction result $\fa x_1,x_2,x_3 \ex y_1(x_1,x_2) : (y_1 \vee x_1) \wedge (\overline{y_1} \vee x_2)$, 
%which is equivalent to the QBF $\fa x_1,x_2 \ex y_1 : (y_1 \vee x_1) \wedge (\overline{y_1} \vee x_2)$, 
which doesn't allow any further autarky. 
%
This is lean kernel of the original formula.

The autarky system $A_0, A_1$ and $E_1$ are too weak for general DQBF solving. Out of total 334 instances of DQBF track of QBFEVAL'18 we only found 4 instances with non-trivial autakies. We are analyzing stronger autarky systems, $A_2$ (function is dependent on 2 universal variables), $E_2$ (only uses two existential variables) and their combination $E_2 + A_2$. 
%
%The complexity of finding an $A_2$ autarky is at second level of polynomial hierarchy whereas for $E_2$ it is not known.

\subsection{Symmetry}
\label{sec:sym}

Symmetry in general is a transformation of an object that leaves the object unchanged.
%
%Recently a general framework of symmetries for QBF was presented .
% 
%In the case of DQBF we analyze two kind of transformations. 
%use group actions to describe symmetries for DQBF. 
%We discuss wo kinds of group actions. 
%
%On the one hand, we consider transformations that map
%Formulas to formulas transformation, i.e. XXX   
%i.e., a group action $G \times BF(X) \to BF(X)$.
%and strategies to strategies transformation i.e. XXX.
%i.e., a group action $G \times S_\exists (P ) \to S_\exists (P)$ or $G \times S_\forall (P) \to S_\forall (P)$. 
%Symmetries are described using groups and group actions. A group is a set $G$ together with an associative binary operation $G \times G \to G$.
%$(g, h) \to gh$. 
%A group has a neutral element and every element has an inverse in $G$. 
%
%A typical examples for a group is the set $Z$ of integers together with addition and group of permutations.
%
%We use group actions to describe symmetries for DQBF. 
%
%In both cases, we consider groups $G$ which preserve the set of winning strategies for a given QBF $F$.
%\subsubsection{Syntactic Symmetry} 
For DQBF we pose a following restriction over the transformation:
\begin{itemize}
   \item The group action preserves propositional satisfiability.
%   \item The variables should be from the same quantifier block.
   \item The dependency of the variable is same. 
\end{itemize}

In advance case we relax the requirement of the variables to have the same dependency. For example \par\noindent
%\begin{align}
%\nonumber\\
% \nonumber
%	%
%\end{align}
%
\begin{equation}
F := \fa x_1,x_2 \ex y_1(x_1) \ex y_2(x_2): (y_1 \lor x_1) \land (y_2 \lor  x_2)
\label{eqn:exs}
\end{equation}
has symmetry $a \to b$. replacing variable $y_1$ with variable $y_2$ do not change the syntactic formula.

%\subsubsection{Symantic Symmetry} 
%XXX

\subsection{Symmetry aware compilation}
The compilation is minimum possibility to make a clause tautology. 
%
Currently the compilation is clausewise and fed directly to a SAT solver to find the suitable autarky.
%
We can use the concept of symmetry to reduce the work by a SAT solver and (most likely) improve the efficiency.
%
The idea is to make the process of solving the problem with communication between clauses (at multi-clause level rather than current state of doing it clausewise).
%
Adding support for avoiding solutions from same orbit will be utilized to search for a solution with less effort.
%
Note that the use of symmetry here is similar to finding symmetry during search, unlike the use of the symmetry breaker. 
 
%Although a direct use of a symmetry breaker can be helpful here a better solution will be   

\section{DQBF solver development}
\label{sec:dev}

A valuable tool for SAT and QBF research is the model for
generating random instances. These instances are useful as a benchmark and investigation of the complexity.

Reasoning for the hard and easy instance use (Fuzz) XXX \\

Delta debugger XXX \\

Certification XXX
%Inherently hard instances for SAT and QBF solvers are essen- tial for designing and testing search methods employed by solvers [Achlioptas, 2009], and are used to assess their performance in solver competitions [Järvisalo et al. 2012; Nar-izzano et al. 2006; Calimeri et al. 2016]. On the flip side,large collections of easy instances support the so-called fuzztesting, used to reveal problems in solver implementation, as well as defects in solver design [Brummayer et al. 2010].

\section{Conclusion}
\label{sec:conc}

We consider $\Eaut_2 + \Aaut_2$ only as a first example and appetiser --- all the SAT-theory on autarkies can be combined with many interesting classes of boolean functions, to yield interesting autarky systems.
The results on the normalforms by the basic autarky systems $\Aaut_0, \Aaut_1, \Eaut_1$ and their combinations, on all known QCNF and DQCNF instances (as in QBFLIB), will be made available online.
After establishing this precise basis, the use of autarkies in pre- and inprocessing is the main question.

\bibliographystyle{plainurl}
%\bibliographystyle{unsrt}
%\bibliography{sample}
\bibliography{fmcad}

%\BibliographyOKlibrary



\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
